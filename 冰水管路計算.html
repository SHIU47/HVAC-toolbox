<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HydroPuzzle Pro - 專業核心優化版</title>
    <!-- 載入 React 與 Babel -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- 載入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: -apple-system, "Segoe UI", Roboto, "Microsoft JhengHei", sans-serif; }
        #root { height: 100vh; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 10px; }
        .canvas-grid {
            background-image: radial-gradient(#cbd5e1 2px, transparent 2px);
            background-size: 60px 60px;
        }
        @keyframes pulse-warning {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
        }
        .warning-pulse { animation: pulse-warning 1.2s infinite ease-in-out; }
        .source-glow { box-shadow: 0 0 80px rgba(234, 179, 8, 0.4), 0 30px 60px -15px rgba(0, 0, 0, 0.3); border: 8px solid #ca8a04 !important; }
        
        .selecting-active, .selecting-active * { 
            user-select: none !important; 
            -webkit-user-select: none !important; 
        }
        
        .node-layer { will-change: transform; transition: outline 0.2s, box-shadow 0.3s; pointer-events: auto !important; }
        .is-dragging { z-index: 5000 !important; cursor: grabbing !important; }

        .modal-overlay { background: rgba(15, 23, 42, 0.85); backdrop-filter: blur(12px); }
        .modal-content { animation: modal-in 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); }
        @keyframes modal-in {
            from { opacity: 0; transform: scale(0.8) translateY(40px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }

        .port-dot { transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); cursor: crosshair; background-color: #0f172a; border: 3px solid white; box-shadow: 0 5px 15px rgba(0,0,0,0.4); z-index: 6000; }
        .port-dot.snap-active { transform: scale(2.5); background-color: #f97316; box-shadow: 0 0 30px #f97316; border-color: white; }
        .port-dot:hover { transform: scale(2.0); background-color: #f97316; box-shadow: 0 0 20px #f97316; }
        
        .copy-mode-active { cursor: crosshair !important; }
        .placement-mode-active { cursor: cell !important; }
        .copy-mode-active .node-layer:hover { outline: 8px solid #10b981 !important; outline-offset: 10px; cursor: copy; }
        
        .selection-box {
            position: fixed;
            background: rgba(16, 185, 129, 0.15);
            border: 2px dashed #10b981;
            border-radius: 4px;
            pointer-events: none;
            z-index: 9999;
        }

        .pipe-label-html {
            position: absolute;
            pointer-events: auto;
            z-index: 300; 
            transform: translate(-50%, -50%);
            will-change: left, top;
        }

        /* 浮動預覽組件 */
        .ghost-group {
            opacity: 0.5;
            pointer-events: none;
            filter: grayscale(0.5);
            z-index: 8000;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo, useCallback, useRef, useEffect } = React;

        const INITIAL_PROJECT_DATA = window.INITIAL_PROJECT_DATA || null;

        const getPathD = (x1, y1, x2, y2, fP, tP) => {
            const mX = (x1 + x2) / 2, mY = (y1 + y2) / 2;
            return (fP === 'bottom' || fP === 'top' || tP === 'bottom' || tP === 'top') 
                ? `M ${x1} ${y1} C ${x1} ${mY}, ${x2} ${mY}, ${x2} ${y2}` 
                : `M ${x1} ${y1} C ${mX} ${y1}, ${mX} ${y2}, ${x2} ${y2}`;
        };
        
        const CP = 4.186; 
        const PIPE_SIZING_DATA = [
            { mm: 20, maxLpm: 19.5, internal: 20.93 },
            { mm: 25, maxLpm: 31.0, internal: 26.64 },
            { mm: 32, maxLpm: 90.0, internal: 35.04 },
            { mm: 40, maxLpm: 140.0, internal: 40.90 },
            { mm: 50, maxLpm: 219.0, internal: 52.70 },
            { mm: 65, maxLpm: 370.0, internal: 67.70 },
            { mm: 80, maxLpm: 560.0, internal: 80.70 },
            { mm: 100, maxLpm: 1020, internal: 105.30 },
            { mm: 125, maxLpm: 1594, internal: 130.80 },
            { mm: 150, maxLpm: 2295, internal: 155.20 },
            { mm: 200, maxLpm: 4080, internal: 204.70 },
            { mm: 250, maxLpm: 6375, internal: 254.20 },
            { mm: 300, maxLpm: 9180, internal: 304.70 },
            { mm: 350, maxLpm: 16064, internal: 350.0 },
            { mm: 400, maxLpm: 20981, internal: 400.0 },
            { mm: 450, maxLpm: 26554, internal: 450.0 },
            { mm: 500, maxLpm: 32783, internal: 500.0 },
            { mm: 550, maxLpm: 39667, internal: 550.0 },
            { mm: 600, maxLpm: 47207, internal: 600.0 },
            { mm: 650, maxLpm: 55403, internal: 650.0 },
            { mm: 700, maxLpm: 64254, internal: 700.0 },
            { mm: 750, maxLpm: 73761, internal: 750.0 },
            { mm: 800, maxLpm: 83923, internal: 800.0 },
            { mm: 850, maxLpm: 94742, internal: 850.0 },
            { mm: 900, maxLpm: 106215, internal: 900.0 },
            { mm: 950, maxLpm: 118345, internal: 950.0 },
            { mm: 1000, maxLpm: 131130, internal: 1000.0 },
            { mm: 1050, maxLpm: 160634, internal: 1050.0 },
            { mm: 1100, maxLpm: 176297, internal: 1100.0 },
            { mm: 1150, maxLpm: 192688, internal: 1150.0 },
            { mm: 1200, maxLpm: 209808, internal: 1200.0 },
            { mm: 1250, maxLpm: 227656, internal: 1250.0 },
            { mm: 1300, maxLpm: 246232, internal: 1300.0 },
            { mm: 1350, maxLpm: 265538, internal: 1350.0 },
            { mm: 1400, maxLpm: 285571, internal: 1400.0 },
            { mm: 1450, maxLpm: 306333, internal: 1450.0 },
            { mm: 1500, maxLpm: 327824, internal: 1500.0 },
            { mm: 1550, maxLpm: 350043, internal: 1550.0 },
            { mm: 1600, maxLpm: 372991, internal: 1600.0 },
            { mm: 1650, maxLpm: 396667, internal: 1650.0 },
            { mm: 1700, maxLpm: 421072, internal: 1700.0 },
            { mm: 1750, maxLpm: 446205, internal: 1750.0 },
            { mm: 1800, maxLpm: 472066, internal: 1800.0 },
            { mm: 1850, maxLpm: 498657, internal: 1850.0 },
            { mm: 1900, maxLpm: 525975, internal: 1900.0 },
            { mm: 1950, maxLpm: 554022, internal: 1950.0 },
            { mm: 2000, maxLpm: 582798, internal: 2000.0 },
            { mm: 2050, maxLpm: 612302, internal: 2050.0 },
            { mm: 2100, maxLpm: 642535, internal: 2100.0 },
            { mm: 2150, maxLpm: 673496, internal: 2150.0 },
            { mm: 2200, maxLpm: 705185, internal: 2200.0 },
            { mm: 2250, maxLpm: 737604, internal: 2250.0 },
            { mm: 2300, maxLpm: 770750, internal: 2300.0 },
            { mm: 2350, maxLpm: 804625, internal: 2350.0 },
            { mm: 2400, maxLpm: 839229, internal: 2400.0 }
        ];

        const HydraulicEngine = {
            calculateLps: (kw, qty, dt) => (Number(kw) * Number(qty || 0)) / (CP * (Number(dt) || 5)),
            getSizing: (totalLps) => {
                const totalLpm = totalLps * 60;
                const match = PIPE_SIZING_DATA.find(p => p.maxLpm >= totalLpm) || PIPE_SIZING_DATA[PIPE_SIZING_DATA.length - 1];
                const area = Math.PI * Math.pow((match.internal / 2) / 1000, 2);
                const velocity = totalLps > 0 ? (totalLps / 1000) / area : 0;
                return { 
                    dn: totalLpm > PIPE_SIZING_DATA[PIPE_SIZING_DATA.length-1].maxLpm ? `${match.mm}+` : match.mm, 
                    velocity, 
                    lpm: totalLpm,
                    warning: velocity > 2.8 
                };
            }
        };

        const COLOR_PALETTE = ['bg-blue-600', 'bg-emerald-600', 'bg-indigo-600', 'bg-red-600', 'bg-orange-600', 'bg-purple-600', 'bg-pink-600', 'bg-cyan-600', 'bg-slate-800'];

        const Icons = {
            Plus: (p) => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round" {...p}><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>,
            Trash2: (p) => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" {...p}><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>,
            Copy: (p) => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" {...p}><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>,
            HardDrive: (p) => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round" {...p}><line x1="22" y1="12" x2="2" y2="12"/><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"/></svg>,
            X: (p) => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="4" strokeLinecap="round" strokeLinejoin="round" {...p}><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>,
            Layers: (p) => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round" {...p}><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></svg>,
            Upload: (p) => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" {...p}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>,
            Save: (p) => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" {...p}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>,
            AlertCircle: (p) => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" {...p}><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>,
            Lock: (p) => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round" {...p}><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>,
            Menu: (p) => <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round" {...p}><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg>,
            Maximize: (p) => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round" {...p}><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>,
            Palette: (p) => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round" {...p}><path d="M12 2a10 10 0 0 0-10 10 10 10 0 0 0 10 10 10.38 10.38 0 0 0 7-2.82 4 4 0 0 0-1-6.66l-1-.2A2 2 0 0 1 15.5 11a2 2 0 0 1 2 2v1a2 2 0 0 0 4 0v-2A10 10 0 0 0 12 2z"/><circle cx="8" cy="9" r="1"/><circle cx="12" cy="7" r="1"/><circle cx="16" cy="9" r="1"/></svg>,
            AlertTriangle: (p) => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round" {...p}><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>
        };

        function App() {
            const [activeTab, setActiveTab] = useState('editor');
            const [library, setLibrary] = useState(INITIAL_PROJECT_DATA?.library || [
                { id: 'lib-dcc-1', label: 'DCC 標準型機組', kw: 49.7, dt: 5, color: 'bg-blue-600' },
                { id: 'lib-mau-1', label: 'MAU 大風量機組', kw: 200, dt: 7, color: 'bg-emerald-600' },
            ]);
            const [nodes, setNodes] = useState(INITIAL_PROJECT_DATA?.nodes || [
                { id: 'src-1', templateId: 'SOURCE', label: '主總管彙整中心', x: 10000, y: 10000, qty: 1 },
                { id: 'pvt-1', type: 'PIVOT', label: '區域分區 A', x: 10600, y: 9850, color: 'bg-red-600' },
                { id: 'inst-1', templateId: 'lib-dcc-1', x: 11400, y: 9850, qty: 6 },
            ]);
            const [pipes, setPipes] = useState(INITIAL_PROJECT_DATA?.pipes || [
                { id: 'p-1', fromId: 'src-1', fromPort: 'right', toId: 'pvt-1', toPort: 'left' },
                { id: 'p-2', fromId: 'pvt-1', fromPort: 'right', toId: 'inst-1', toPort: 'left' },
            ]);

            const [history, setHistory] = useState([]);
            const saveHistory = useCallback(() => {
                const snapshot = JSON.stringify({ library, nodes, pipes });
                setHistory(prev => [snapshot, ...prev].slice(0, 20));
            }, [library, nodes, pipes]);

            const undo = useCallback(() => {
                if (history.length === 0) return;
                const [lastState, ...rest] = history;
                const data = JSON.parse(lastState);
                setLibrary(data.library);
                setNodes(data.nodes);
                setPipes(data.pipes);
                setHistory(rest);
            }, [history]);

            const [scale, setScale] = useState(INITIAL_PROJECT_DATA?.viewState?.scale || 0.6);
            const [offset, setOffset] = useState(INITIAL_PROJECT_DATA?.viewState?.offset || { x: window.innerWidth / 2 - 10000 * 0.6, y: window.innerHeight / 2 - 10000 * 0.6 });
            
            const [results, setResults] = useState([]);
            const [nodeCalculatedFlows, setNodeCalculatedFlows] = useState({});
            const [message, setMessage] = useState(null);
            const [showExportModal, setShowExportModal] = useState(false);
            const [passwordInput, setPasswordInput] = useState("");
            
            const isDraggingRef = useRef(false);
            const fileInputRef = useRef(null);

            const showToast = (txt) => { setMessage(txt); setTimeout(() => setMessage(null), 3000); };

            const solveHydraulics = useCallback(() => {
                const getWeight = (n) => n.templateId === 'SOURCE' ? 0 : n.type === 'PIVOT' ? 1 : 2;
                const nodeMap = {}; nodes.forEach(n => nodeMap[n.id] = n);

                const baseFlowLpsMap = {};
                nodes.forEach(node => {
                    const weight = getWeight(node);
                    if (weight < 2) { baseFlowLpsMap[node.id] = 0; } 
                    else if (node.isMerged) { baseFlowLpsMap[node.id] = HydraulicEngine.calculateLps(node.customKw || 0, 1, 5); } 
                    else {
                        const libItem = library.find(l => l.id === node.templateId);
                        baseFlowLpsMap[node.id] = HydraulicEngine.calculateLps(node.customKw || libItem?.kw || 0, node.qty || 1, libItem?.dt || 5);
                    }
                });

                const adj = {}; nodes.forEach(n => adj[n.id] = []);
                pipes.forEach(p => { if (adj[p.fromId] && adj[p.toId]) { adj[p.fromId].push(p.toId); adj[p.toId].push(p.fromId); } });

                const dists = {};
                const sources = nodes.filter(n => n.templateId === 'SOURCE');
                const queue = [...sources.map(s => s.id)];
                sources.forEach(s => dists[s.id] = 0);
                while (queue.length > 0) {
                    const curr = queue.shift();
                    adj[curr]?.forEach(neighbor => { if (dists[neighbor] === undefined) { dists[neighbor] = dists[curr] + 1; queue.push(neighbor); } });
                }

                const memo = {};
                const getSubtreeLpm = (nodeId, parentId = null) => {
                    const cacheKey = `${nodeId}-${parentId}`; if (memo[cacheKey] !== undefined) return memo[cacheKey];
                    let sum = (baseFlowLpsMap[nodeId] || 0) * 60;
                    adj[nodeId]?.forEach(neighbor => {
                        const nNeighbor = nodeMap[neighbor];
                        if (!nNeighbor) return;
                        if (neighbor !== parentId && (getWeight(nNeighbor) > getWeight(nodeMap[nodeId]) || (getWeight(nNeighbor) === getWeight(nodeMap[nodeId]) && dists[neighbor] > dists[nodeId]))) {
                            sum += getSubtreeLpm(neighbor, nodeId);
                        }
                    });
                    memo[cacheKey] = sum; return sum;
                };

                const nodeAggregates = {}; nodes.forEach(node => { nodeAggregates[node.id] = getSubtreeLpm(node.id); });
                const pipeResults = pipes.map(p => {
                    const n1 = nodeMap[p.fromId], n2 = nodeMap[p.toId];
                    if(!n1 || !n2) return p;
                    const downstreamId = (getWeight(n1) < getWeight(n2) || dists[p.fromId] < dists[p.toId]) ? p.toId : p.fromId;
                    const totalLpm = getSubtreeLpm(downstreamId, (downstreamId === p.toId ? p.fromId : p.toId));
                    return { ...p, lpm: totalLpm, ...HydraulicEngine.getSizing(totalLpm / 60) };
                });

                setResults(pipeResults); setNodeCalculatedFlows(nodeAggregates);
            }, [nodes, pipes, library]);

            useEffect(() => { if (!isDraggingRef.current) solveHydraulics(); }, [nodes, pipes, library, solveHydraulics]);

            const confirmExport = () => {
                if (passwordInput === "900407") {
                    const projectData = { library, nodes, pipes, viewState: { scale, offset } };
                    const updatedHtml = document.documentElement.outerHTML.replace(/const INITIAL_PROJECT_DATA = (null|{.*?});/, `const INITIAL_PROJECT_DATA = ${JSON.stringify(projectData)};`);
                    const blob = new Blob(["<!DOCTYPE html>\n" + updatedHtml], { type: 'text/html' });
                    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `HydroPro_Project.html`; a.click();
                    setShowExportModal(false); showToast("導出成功。");
                } else { showToast("密碼錯誤。"); }
            };

            const handleImportHTML = (e) => {
                const file = e.target.files[0]; if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    const match = event.target.result.match(/const INITIAL_PROJECT_DATA = (\{.*?\});/);
                    if (match) {
                        try {
                            const data = JSON.parse(match[1]);
                            setLibrary(data.library || []); setNodes(data.nodes || []); setPipes(data.pipes || []);
                            if (data.viewState) { setScale(data.viewState.scale || 0.6); setOffset(data.viewState.offset || { x: 0, y: 0 }); }
                            showToast("導入成功。");
                        } catch (err) { showToast("解析失敗。"); }
                    } else { showToast("無效檔案。"); }
                };
                reader.readAsText(file); e.target.value = '';
            };

            return (
                <div className="w-full h-screen bg-slate-100 flex flex-col overflow-hidden text-slate-900 leading-tight">
                    {message && (
                        <div className="fixed top-20 left-1/2 -translate-x-1/2 bg-slate-900 text-white px-8 py-3 rounded-full z-[1000] shadow-2xl flex items-center gap-3 animate-bounce border border-slate-700 font-black">
                            <Icons.AlertCircle className="text-yellow-400" /> <span>{message}</span>
                        </div>
                    )}
                    {showExportModal && (
                        <div className="fixed inset-0 z-[2000] flex items-center justify-center modal-overlay">
                            <div className="bg-white w-[400px] rounded-[3rem] p-10 shadow-2xl modal-content border-t-8 border-blue-600 text-center">
                                <div className="bg-blue-50 p-6 rounded-full text-blue-600 mb-6 inline-block"><Icons.Lock /></div>
                                <h3 className="text-xl font-black text-slate-800 mb-2 underline decoration-blue-200">安全授權驗證</h3>
                                <input type="password" autoFocus className="w-full p-4 bg-slate-50 border-2 rounded-2xl mb-8 text-center text-xl tracking-[0.5em] font-black outline-none focus:border-blue-500" value={passwordInput} onChange={(e) => setPasswordInput(e.target.value)} onKeyDown={(e) => e.key === 'Enter' && confirmExport()} />
                                <div className="flex gap-3">
                                    <button onClick={() => setShowExportModal(false)} className="flex-1 py-3 rounded-xl font-bold text-slate-400 hover:bg-slate-100 transition-colors">取消</button>
                                    <button onClick={confirmExport} className="flex-1 py-3 bg-blue-600 text-white rounded-xl font-black shadow-lg transition-all">確認</button>
                                </div>
                            </div>
                        </div>
                    )}
                    <header className="h-14 bg-slate-900 text-white flex items-center px-4 shrink-0 z-[200] shadow-xl">
                        <div className="flex items-center gap-3 mr-8 border-r border-slate-700 pr-8 font-black uppercase italic">
                            <div className="bg-blue-600 p-1.5 rounded-lg shadow-lg"><Icons.HardDrive /></div>
                            <div className="flex flex-col leading-none tracking-tighter"><span className="text-sm">HydroPuzzle</span><span className="text-[10px] text-blue-400 font-bold">PRO-V4</span></div>
                        </div>
                        <button onClick={() => setActiveTab('setup')} className={`px-4 h-full text-xs font-bold transition-all ${activeTab === 'setup' ? 'bg-white/10 border-b-2 border-blue-400 text-blue-400' : 'opacity-60'}`}>規格定義</button>
                        <button onClick={() => setActiveTab('editor')} className={`px-4 h-full text-xs font-bold transition-all ${activeTab === 'editor' ? 'bg-white/10 border-b-2 border-blue-400 text-blue-400' : 'opacity-60'}`}>製圖空間</button>
                        <div className="ml-auto flex items-center gap-3">
                            <input type="file" accept=".html" className="hidden" ref={fileInputRef} onChange={handleImportHTML} />
                            <button onClick={() => fileInputRef.current.click()} className="bg-slate-700 hover:bg-slate-600 text-white px-3 py-1.5 rounded-lg text-[10px] font-black flex items-center gap-2 active:scale-95 transition-all shadow-lg"><Icons.Upload /> 匯入</button>
                            <button onClick={() => {setPasswordInput(""); setShowExportModal(true);}} className="bg-emerald-600 hover:bg-emerald-500 text-white px-3 py-1.5 rounded-lg text-[10px] font-black flex items-center gap-2 active:scale-95 transition-all shadow-lg"><Icons.Save /> 導出</button>
                        </div>
                    </header>
                    <div className="flex-1 relative overflow-hidden">
                        {activeTab === 'setup' ? (
                            <EquipmentSetup library={library} setLibrary={setLibrary} saveHistory={saveHistory} />
                        ) : (
                            <HydraulicEditor library={library} nodes={nodes} setNodes={setNodes} pipes={pipes} setPipes={setPipes} scale={scale} setScale={setScale} offset={offset} setOffset={setOffset} results={results} nodeFlows={nodeCalculatedFlows} isDraggingRef={isDraggingRef} solveHydraulics={solveHydraulics} showToast={showToast} saveHistory={saveHistory} undo={undo} />
                        )}
                    </div>
                </div>
            );
        }

        function EquipmentSetup({ library, setLibrary, saveHistory }) {
            const [activePickerId, setActivePickerId] = useState(null);
            const update = (id, field, val) => {
                saveHistory();
                setLibrary(prev => prev.map(item => item.id === id ? { ...item, [field]: val } : item));
            };
            return (
                <div className="p-12 h-full overflow-y-auto bg-slate-50" onClick={() => setActivePickerId(null)}>
                    <div className="max-w-[1000px] mx-auto text-left">
                        <div className="flex justify-between items-center mb-8">
                            <h2 className="text-3xl font-black text-slate-800 tracking-tight underline decoration-blue-400 decoration-8 underline-offset-8">標準參數庫</h2>
                            <button onClick={(e) => { e.stopPropagation(); saveHistory(); setLibrary([...library, { id: `lib-${Date.now()}`, label: '新機組模板', kw: 100, dt: 5, color: 'bg-blue-600' }])}} className="bg-blue-600 text-white px-8 py-4 rounded-2xl font-black text-base flex items-center gap-3 shadow-xl hover:bg-blue-700 transition-all"><Icons.Plus /> 新增模板</button>
                        </div>
                        <div className="bg-white rounded-[2.5rem] shadow-2xl border-2 border-slate-100 overflow-visible text-left">
                            <table className="w-full text-base">
                                <thead className="bg-slate-900 text-slate-400 uppercase font-black text-xs">
                                    <tr><th className="px-8 py-6">名稱</th><th className="px-4 py-6 text-center">配色</th><th className="px-4 py-6 text-center">kW</th><th className="px-4 py-6 text-center">DT (K)</th><th className="px-4 py-6 text-center text-emerald-400 font-black">計算 LPM</th><th className="px-8 py-6 text-right">管理</th></tr>
                                </thead>
                                <tbody className="divide-y divide-slate-100 font-bold text-slate-700">
                                    {library.map(item => (
                                        <tr key={item.id} className="hover:bg-blue-50/40 transition-colors">
                                            <td className="px-8 py-6 font-black text-xl text-slate-800"><input className="bg-transparent border-b-2 border-transparent focus:border-blue-500 outline-none w-full" value={item.label} onChange={e => update(item.id, 'label', e.target.value)} /></td>
                                            <td className="px-4 py-6 text-center relative overflow-visible">
                                                <div className={`w-10 h-10 rounded-2xl mx-auto border-4 border-white shadow-lg cursor-pointer ${item.color}`} onClick={(e) => { e.stopPropagation(); setActivePickerId(activePickerId === item.id ? null : item.id); }} />
                                                {activePickerId === item.id && (
                                                    <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-3 bg-white p-4 rounded-3xl shadow-2xl border-2 z-[999] w-[180px] grid grid-cols-3 gap-3" onClick={e => e.stopPropagation()}>
                                                        {COLOR_PALETTE.map(c => (<div key={c} className={`w-10 h-10 rounded-full cursor-pointer ${c} ${item.color === c ? 'ring-4 ring-slate-800 ring-offset-2' : ''}`} onClick={() => { update(item.id, 'color', c); setActivePickerId(null); }} />))}
                                                    </div>
                                                )}
                                            </td>
                                            <td className="px-4 py-6 text-center text-xl font-black"><input type="number" className="w-24 text-center bg-slate-50 p-2 rounded-xl" value={item.kw} onChange={e => update(item.id, 'kw', parseFloat(e.target.value)||0)} /></td>
                                            <td className="px-4 py-6 text-center text-xl font-black"><input type="number" className="w-20 text-center bg-slate-100 p-2 rounded-xl" value={item.dt} onChange={e => update(item.id, 'dt', parseFloat(e.target.value)||0)} /></td>
                                            <td className="px-4 py-6 text-center font-black text-2xl text-emerald-600">{(item.kw/(CP*item.dt)*60).toFixed(1)}</td>
                                            <td className="px-8 py-6 text-right"><button onClick={() => { saveHistory(); setLibrary(library.filter(l => l.id !== item.id))}} className="text-slate-300 hover:text-red-500 transition-all p-2 transform hover:scale-125"><Icons.Trash2 /></button></td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            );
        }

        function HydraulicEditor({ library, nodes, setNodes, pipes, setPipes, scale, setScale, offset, setOffset, results, nodeFlows, isDraggingRef, solveHydraulics, showToast, saveHistory, undo }) {
            const [selectedNodes, setSelectedNodes] = useState(new Set());
            const [activeConn, setActiveConn] = useState(null); 
            const [sidebarOpen, setSidebarOpen] = useState(true);
            const [snapPort, setSnapPort] = useState(null);
            const [activeColorPickerId, setActiveColorPickerId] = useState(null);
            const [copyToolActive, setCopyToolActive] = useState(false);
            const [selectionBox, setSelectionBox] = useState(null);
            const [placementGroup, setPlacementGroup] = useState(null);

            const containerRef = useRef(null);
            const nodesSnapshot = useRef(nodes);
            const pipesSnapshot = useRef(pipes);
            const nodeMapSnapshot = useRef({});
            const lastMousePos = useRef({ x: 0, y: 0 });
            const rafId = useRef(null);
            
            const renderNodeMap = useMemo(() => {
                const m = {}; nodes.forEach(n => m[n.id] = n);
                return m;
            }, [nodes]);

            useEffect(() => { 
                nodesSnapshot.current = nodes; 
                nodeMapSnapshot.current = renderNodeMap;
            }, [nodes, renderNodeMap]);
            useEffect(() => { pipesSnapshot.current = pipes; }, [pipes]);

            const dragInfo = useRef({ isDragging: false, id: null, startX: 0, startY: 0, connectedPipeIds: [], dx: 0, dy: 0, isPanning: false, isSelecting: false });
            const nodeRefs = useRef({}); const pathRefs = useRef({}); const labelRefs = useRef({}); const ghostPathRef = useRef(null);

            const getNodeDimensions = (node) => {
                const isS = node?.templateId === 'SOURCE'; const isP = node?.type === 'PIVOT'; const isM = node?.isMerged;
                let w = 500, h = 320; 
                if (isS) { w = 480; h = 320; } 
                else if (isM) { w = 480; h = 100 + (Object.keys(node.composition || {}).length * 40) + 180; }
                else if (isP) { w = 460; h = 320; }
                return { w, h };
            };

            const getPortOffset = (pT, node) => {
                const { w, h } = getNodeDimensions(node);
                if (pT === 'left') return { x: 0, y: h/2 }; 
                if (pT === 'right') return { x: w, y: h/2 };
                if (pT === 'top') return { x: w/2, y: 0 }; 
                if (pT === 'bottom') return { x: w/2, y: h };
                return { x: 0, y: 0 };
            };

            const screenToWorld = useCallback((sx, sy) => ({
                x: (sx - offset.x) / scale,
                y: (sy - offset.y) / scale
            }), [offset, scale]);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.key === "Escape") {
                        setActiveConn(null);
                        setPlacementGroup(null);
                        setSelectionBox(null);
                        setSelectedNodes(new Set());
                        setCopyToolActive(false);
                    }
                    if (e.ctrlKey && e.key === "z") {
                        e.preventDefault();
                        undo();
                    }
                };
                window.addEventListener("keydown", handleKeyDown);
                return () => window.removeEventListener("keydown", handleKeyDown);
            }, [undo]);

            const generatePlacementGroup = useCallback((selectedNodeIds) => {
                if (selectedNodeIds.length === 0) return;
                const idMap = {};
                const newNodesArr = [];
                let minX = Infinity, minY = Infinity;
                selectedNodeIds.forEach(id => {
                    const original = nodeMapSnapshot.current[id];
                    if (original) {
                        minX = Math.min(minX, original.x);
                        minY = Math.min(minY, original.y);
                    }
                });
                selectedNodeIds.forEach(id => {
                    const original = nodeMapSnapshot.current[id];
                    if (original) {
                        const newId = `${original.templateId === 'SOURCE' ? 'src' : (original.type === 'PIVOT' ? 'pvt' : 'inst')}-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;
                        idMap[id] = newId;
                        newNodesArr.push({ ...original, id: newId, relativeX: original.x - minX, relativeY: original.y - minY });
                    }
                });
                const newPipesArr = [];
                pipesSnapshot.current.forEach(p => {
                    if (idMap[p.fromId] && idMap[p.toId]) {
                        newPipesArr.push({
                            ...p,
                            id: `p-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
                            fromId: idMap[p.fromId],
                            toId: idMap[p.toId]
                        });
                    }
                });
                setPlacementGroup({ nodes: newNodesArr, pipes: newPipesArr });
                setSelectedNodes(new Set());
                showToast("請移動滑鼠選擇放置位置，點擊左鍵放下 (ESC 取消)");
            }, []);

            useEffect(() => {
                const container = containerRef.current; if (!container) return;
                const handleWheelNative = (e) => {
                    e.preventDefault();
                    const factor = Math.pow(1.15, -e.deltaY / 120);
                    const newScale = Math.min(Math.max(scale * factor, 0.08), 3.0);
                    const rect = container.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left, mouseY = e.clientY - rect.top;
                    setOffset(prev => ({ x: mouseX - (mouseX - prev.x) * (newScale / scale), y: mouseY - (mouseY - prev.y) * (newScale / scale) }));
                    setScale(newScale);
                };
                container.addEventListener('wheel', handleWheelNative, { passive: false });
                return () => container.removeEventListener('wheel', handleWheelNative);
            }, [scale, offset]);

            const handleResetView = () => {
                if (nodes.length === 0) return;
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                nodes.forEach(n => {
                    const { w, h } = getNodeDimensions(n);
                    minX = Math.min(minX, n.x); maxX = Math.max(maxX, n.x + w);
                    minY = Math.min(minY, n.y); maxY = Math.max(maxY, n.y + h);
                });
                const contentW = maxX - minX, contentH = maxY - minY;
                const rect = containerRef.current.getBoundingClientRect();
                const padding = 150;
                const newScale = Math.min((rect.width - padding) / contentW, (rect.height - padding) / contentH, 1.2);
                setScale(newScale);
                setOffset({ x: rect.width / 2 - (minX + contentW / 2) * newScale, y: rect.height / 2 - (minY + contentH / 2) * newScale });
            };

            const getSpawnPoint = useCallback(() => {
                const rect = containerRef.current?.getBoundingClientRect() || { width: window.innerWidth, height: window.innerHeight };
                return { x: (rect.width/2 - offset.x)/scale - 250, y: (rect.height/2 - offset.y)/scale - 160 };
            }, [offset, scale]);

            const onMouseMove = useCallback((e) => {
                lastMousePos.current = { x: e.clientX, y: e.clientY };
                if (dragInfo.current.isPanning) { 
                    setOffset({ x: e.clientX - dragInfo.current.startX, y: e.clientY - dragInfo.current.startY }); 
                    return; 
                }
                
                if (dragInfo.current.isSelecting) {
                    setSelectionBox(prev => ({ ...prev, endX: e.clientX, endY: e.clientY }));
                    return;
                }

                if (placementGroup) {
                    // 強制重繪
                    setPlacementGroup(prev => ({...prev}));
                    return;
                }

                if (activeConn && ghostPathRef.current) {
                    const tx = (e.clientX - offset.x) / scale, ty = (e.clientY - offset.y) / scale;
                    let foundSnap = null;
                    for (const nodeItem of nodesSnapshot.current) {
                        if (nodeItem.id === activeConn.fromId) continue;
                        ['left', 'right', 'top', 'bottom'].forEach(pKey => {
                            const off = getPortOffset(pKey, nodeItem); const px = nodeItem.x + off.x, py = nodeItem.y + off.y;
                            if (Math.sqrt(Math.pow(tx - px, 2) + Math.pow(ty - py, 2)) < 65 / scale) foundSnap = { nodeId: nodeItem.id, port: pKey, x: px, y: py };
                        });
                    }
                    const targetX = foundSnap ? foundSnap.x : tx, targetY = foundSnap ? foundSnap.y : ty;
                    setSnapPort(foundSnap);
                    ghostPathRef.current.setAttribute('d', getPathD(activeConn.startX, activeConn.startY, targetX, targetY, activeConn.fromPort, foundSnap ? foundSnap.port : 'left'));
                    return;
                }
                
                if (!dragInfo.current.isDragging) return;
                
                if (rafId.current) return;
                rafId.current = window.requestAnimationFrame(() => {
                    rafId.current = null;
                    if (!dragInfo.current.isDragging) return;
                    
                    const { id, startX, startY, connectedPipeIds } = dragInfo.current;
                    const dx = (e.clientX - startX) / scale, dy = (e.clientY - startY) / scale;
                    dragInfo.current.dx = dx; dragInfo.current.dy = dy;
                    const movingSet = selectedNodes.has(id) ? selectedNodes : new Set([id]);
                    
                    movingSet.forEach(mId => { 
                        if (nodeRefs.current[mId]) {
                            nodeRefs.current[mId].style.transform = `translate3d(${dx}px, ${dy}px, 0)`; 
                            nodeRefs.current[mId].classList.add('is-dragging');
                        }
                    });
                    
                    connectedPipeIds.forEach(pId => {
                        const pItem = pipesSnapshot.current.find(pip => pip.id === pId); 
                        if (!pItem || !pathRefs.current[pId]) return;
                        
                        const fN = movingSet.has(pItem.fromId) ? { ...nodeMapSnapshot.current[pItem.fromId], x: (nodeMapSnapshot.current[pItem.fromId]?.x || 0) + dx, y: (nodeMapSnapshot.current[pItem.fromId]?.y || 0) + dy } : nodeMapSnapshot.current[pItem.fromId];
                        const tN = movingSet.has(pItem.toId) ? { ...nodeMapSnapshot.current[pItem.toId], x: (nodeMapSnapshot.current[pItem.toId]?.x || 0) + dx, y: (nodeMapSnapshot.current[pItem.toId]?.y || 0) + dy } : nodeMapSnapshot.current[pItem.toId];
                        
                        if (!fN || !tN) return;
                        
                        const o1 = getPortOffset(pItem.fromPort, fN), o2 = getPortOffset(pItem.toPort, tN);
                        const x1 = fN.x + o1.x, y1 = fN.y + o1.y, x2 = tN.x + o2.x, y2 = tN.y + o2.y;
                        
                        pathRefs.current[pId].setAttribute('d', getPathD(x1, y1, x2, y2, pItem.fromPort, pItem.toPort));
                        if (labelRefs.current[pId]) {
                            labelRefs.current[pId].style.left = `${(x1 + x2) / 2}px`;
                            labelRefs.current[pId].style.top = `${(y1 + y2) / 2}px`;
                        }
                    });
                });
            }, [scale, offset, activeConn, selectedNodes, solveHydraulics, placementGroup]);

            const onMouseUp = useCallback(() => {
                document.body.classList.remove('dragging-active');
                document.body.classList.remove('selecting-active');
                
                if (dragInfo.current.isSelecting && selectionBox) {
                    const wStart = screenToWorld(selectionBox.startX, selectionBox.startY);
                    const wEnd = screenToWorld(selectionBox.endX, selectionBox.endY);
                    const xMin = Math.min(wStart.x, wEnd.x), xMax = Math.max(wStart.x, wEnd.x);
                    const yMin = Math.min(wStart.y, wEnd.y), yMax = Math.max(wStart.y, wEnd.y);
                    const insideIds = nodesSnapshot.current.filter(n => {
                        const { w, h } = getNodeDimensions(n);
                        const centerX = n.x + w/2, centerY = n.y + h/2;
                        return centerX >= xMin && centerX <= xMax && centerY >= yMin && centerY <= yMax;
                    }).map(n => n.id);
                    if (insideIds.length > 0) generatePlacementGroup(insideIds);
                    setSelectionBox(null);
                    dragInfo.current.isSelecting = false;
                    return;
                }

                if (dragInfo.current.isDragging) {
                    const { dx, dy, id } = dragInfo.current;
                    const movingSet = selectedNodes.has(id) ? selectedNodes : new Set([id]);
                    if (Math.abs(dx) > 1 || Math.abs(dy) > 1) {
                        saveHistory();
                        setNodes(prev => prev.map(n => movingSet.has(n.id) ? { ...n, x: n.x + dx, y: n.y + dy } : n));
                    }
                    movingSet.forEach(mId => { 
                        if (nodeRefs.current[mId]) {
                            nodeRefs.current[mId].style.transform = 'translate3d(0,0,0)'; 
                            nodeRefs.current[mId].classList.remove('is-dragging');
                        }
                    });
                    dragInfo.current.isDragging = false; 
                    isDraggingRef.current = false;
                }
                
                if (activeConn && snapPort) {
                    const isDup = pipesSnapshot.current.some(p => p.fromId === activeConn.fromId && p.toId === snapPort.nodeId && p.fromPort === activeConn.fromPort && p.toPort === snapPort.port);
                    if (!isDup) {
                        saveHistory();
                        setPipes(prev => [...prev, { id: `p-${Date.now()}-${Math.random()}`, fromId: activeConn.fromId, fromPort: activeConn.fromPort, toId: snapPort.nodeId, toPort: snapPort.port }]);
                    }
                }
                
                dragInfo.current.isPanning = false; 
                setActiveConn(null); 
                setSnapPort(null);
                if (ghostPathRef.current) ghostPathRef.current.setAttribute('d', '');
            }, [activeConn, snapPort, selectedNodes, setNodes, setPipes, selectionBox, screenToWorld, generatePlacementGroup, saveHistory]);

            const onMouseDown = useCallback((e) => {
                if (placementGroup) {
                    saveHistory();
                    const worldPos = screenToWorld(e.clientX, e.clientY);
                    const finalNodes = placementGroup.nodes.map(n => ({
                        ...n,
                        x: worldPos.x + n.relativeX,
                        y: worldPos.y + n.relativeY,
                        relativeX: undefined,
                        relativeY: undefined
                    }));
                    setNodes(prev => [...prev, ...finalNodes]);
                    setPipes(prev => [...prev, ...placementGroup.pipes]);
                    setPlacementGroup(null);
                    setCopyToolActive(false);
                    showToast("圖塊已放置。");
                    return;
                }

                if(e.button===1 || (e.button===0&&e.shiftKey)) { 
                    e.preventDefault(); dragInfo.current.isPanning=true; dragInfo.current.startX=e.clientX-offset.x; dragInfo.current.startY=e.clientY-offset.y; 
                }
                else if (copyToolActive && (e.target.tagName === 'svg' || e.target.classList.contains('canvas-grid') || e.target.closest('.canvas-grid'))) {
                    e.preventDefault(); 
                    document.body.classList.add('selecting-active');
                    dragInfo.current.isSelecting = true;
                    setSelectionBox({ startX: e.clientX, startY: e.clientY, endX: e.clientX, endY: e.clientY });
                }
                else if (e.target.tagName === 'svg' || e.target.classList.contains('canvas-grid')) { 
                    setSelectedNodes(new Set()); setActiveColorPickerId(null); 
                }
            }, [placementGroup, screenToWorld, copyToolActive, offset, setNodes, setPipes, saveHistory]);

            useEffect(() => {
                window.addEventListener('mousemove', onMouseMove); 
                window.addEventListener('mouseup', onMouseUp);
                return () => { 
                    window.removeEventListener('mousemove', onMouseMove); 
                    window.removeEventListener('mouseup', onMouseUp); 
                };
            }, [onMouseMove, onMouseUp]);

            const handleMergeAction = () => {
                if (selectedNodes.size < 2) return;
                const list = nodes.filter(n => selectedNodes.has(n.id) && n.templateId !== 'SOURCE');
                if (list.length < 2) return;
                saveHistory();
                const avgX = list.reduce((s,n)=>s+n.x,0)/list.length, avgY = list.reduce((s,n)=>s+n.y,0)/list.length;
                const composition = {}; let totalKw = 0;
                list.forEach(n => {
                    const libItem = library.find(l => l.id === n.templateId);
                    if(!composition[n.templateId]) composition[n.templateId] = { label: n.label || libItem?.label || "設備", qty: 0 };
                    composition[n.templateId].qty += (n.qty || 1);
                    totalKw += (n.customKw !== undefined ? n.customKw : (libItem?.kw || 0)) * (n.qty || 1);
                });
                const newId = `merged-${Date.now()}`;
                const newPipesArr = pipes.map(p => {
                    const fromS = selectedNodes.has(p.fromId), toS = selectedNodes.has(p.toId);
                    if (fromS && toS) return null;
                    if (fromS) return { ...p, fromId: newId };
                    if (toS) return { ...p, toId: newId };
                    return p;
                }).filter(p => p);
                setNodes(prev => [...prev.filter(n => !selectedNodes.has(n.id)), { id: newId, isMerged: true, label: "多負載彙整區域", x: avgX, y: avgY, customKw: totalKw, composition, color: 'bg-indigo-700' }]);
                setPipes(newPipesArr); setSelectedNodes(new Set([newId]));
            };

            const handleUnmerge = (nodeId) => {
                const nodeItem = renderNodeMap[nodeId]; if (!nodeItem || !nodeItem.isMerged) return;
                saveHistory();
                const restoredNodesArr = []; let oY = 0;
                Object.keys(nodeItem.composition).forEach(libId => {
                    const c = nodeItem.composition[libId];
                    restoredNodesArr.push({ id: `inst-${Date.now()}-${libId}`, templateId: libId, label: c.label, x: nodeItem.x + 350, y: nodeItem.y + oY, qty: c.qty });
                    oY += 180;
                });
                const firstId = restoredNodesArr[0].id;
                setPipes(prev => prev.map(p => (p.fromId===nodeId?{...p,fromId:firstId}:(p.toId===nodeId?{...p,toId:firstId}:p))));
                setNodes(prev => [...prev.filter(n => n.id !== nodeId), ...restoredNodesArr]); setSelectedNodes(new Set());
            };

            const mouseWorldPos = screenToWorld(lastMousePos.current.x, lastMousePos.current.y);

            return (
                <div ref={containerRef} className={`flex h-full w-full bg-slate-200 relative overflow-hidden canvas-grid ${copyToolActive ? 'copy-mode-active' : ''} ${placementGroup ? 'placement-mode-active' : ''}`} onMouseDown={onMouseDown}>
                    {selectionBox && (
                        <div className="selection-box" style={{
                            left: Math.min(selectionBox.startX, selectionBox.endX),
                            top: Math.min(selectionBox.startY, selectionBox.endY),
                            width: Math.abs(selectionBox.startX - selectionBox.endX),
                            height: Math.abs(selectionBox.startY - selectionBox.endY)
                        }} />
                    )}

                    <div className={`absolute left-4 top-4 bottom-4 w-52 bg-white shadow-2xl rounded-3xl z-[150] transition-all duration-500 flex flex-col border-4 border-slate-100 ${sidebarOpen ? 'translate-x-0' : '-translate-x-[300px] opacity-0'}`}>
                        <div className="p-4 border-b flex justify-between items-center font-black text-[10px] uppercase text-slate-400"><span>Library</span><button onClick={() => setSidebarOpen(false)} className="hover:text-slate-800 transition-all"><Icons.X /></button></div>
                        <div className="flex-1 p-3 space-y-4 overflow-y-auto">
                            <button onClick={() => { setCopyToolActive(!copyToolActive); setSelectedNodes(new Set()); setPlacementGroup(null); }} className={`w-full p-4 rounded-2xl flex items-center justify-between border-4 transition-all font-black uppercase text-xs tracking-tighter ${copyToolActive ? 'bg-emerald-500 text-white border-emerald-600 scale-105 shadow-xl' : 'bg-slate-100 text-slate-500 border-slate-200 hover:bg-slate-200'}`}>
                                <span>Copy Mode</span>
                                <Icons.Copy />
                            </button>
                            <div className="h-px bg-slate-100 my-2" />
                            <button onClick={() => { saveHistory(); const p = getSpawnPoint(); setNodes(prev => [...prev, { id: `src-${Date.now()}`, templateId: 'SOURCE', label: '主總管彙整中心', x: p.x, y: p.y, qty: 1 }])}} className="w-full p-5 bg-yellow-400 rounded-2xl hover:scale-[1.05] shadow-lg flex items-center justify-between border-4 border-yellow-500 transition-all font-black uppercase text-xs tracking-tighter pointer-events-auto"><span>Header</span><Icons.Plus /></button>
                            <button onClick={() => { saveHistory(); const p = getSpawnPoint(); setNodes(prev => [...prev, { id: `pvt-${Date.now()}`, type: 'PIVOT', label: '區域分區支點', x: p.x, y: p.y, color: 'bg-slate-800' }])}} className="w-full p-5 bg-slate-800 text-white rounded-2xl hover:scale-[1.05] shadow-lg flex items-center justify-between border-4 border-slate-950 transition-all font-black uppercase text-xs tracking-tighter pointer-events-auto"><span>Pivot</span><Icons.Plus /></button>
                            <div className="h-px bg-slate-100 my-2" />
                            {library.map(lib => (
                                <button key={lib.id} onClick={() => { saveHistory(); const p = getSpawnPoint(); setNodes(prev => [...prev, { id: `inst-${Date.now()}`, templateId: lib.id, label: lib.label, x: p.x, y: p.y, qty: 1, color: lib.color }])}} className="w-full p-3 bg-white border-2 border-slate-50 rounded-[1.2rem] hover:border-blue-500 shadow-sm flex items-center gap-4 active:scale-95 transition-all text-left">
                                    <div className={`w-2.5 h-10 rounded-full ${lib.color}`} /><div className="flex-1 overflow-hidden font-black"><div className="text-xs text-slate-800 truncate leading-tight font-black">{lib.label}</div><div className="text-[9px] text-blue-600 mt-0.5 uppercase tracking-tighter font-black">{lib.kw} kW</div></div>
                                </button>
                            ))}
                        </div>
                    </div>
                    {!sidebarOpen && (
                        <button onClick={() => setSidebarOpen(true)} className="absolute left-6 top-6 bg-slate-900 text-white p-5 rounded-3xl shadow-2xl z-[150] border-4 border-white transition-all hover:scale-110 animate-in fade-in zoom-in">
                            <Icons.Menu />
                        </button>
                    )}

                    {selectedNodes.size > 1 && !copyToolActive && !placementGroup && (
                        <div className="absolute top-8 left-1/2 -translate-x-1/2 bg-white px-10 py-5 rounded-[2.5rem] shadow-2xl border-[6px] border-blue-600 z-[250] flex items-center gap-8 animate-in slide-in-from-top-10">
                            <div className="flex flex-col font-black text-left leading-none"><span className="text-xs text-blue-500 uppercase tracking-widest mb-1">Group Management</span><span className="text-2xl font-black tracking-tighter italic">已選中 {selectedNodes.size} 個設備組件</span></div>
                            <button onClick={handleMergeAction} className="bg-blue-600 text-white px-10 py-4 rounded-3xl font-black text-xl uppercase flex items-center gap-4 hover:bg-blue-500 shadow-xl transition-all active:scale-95"><Icons.Layers /> 執行大總量合併</button>
                        </div>
                    )}

                    <main className="flex-1 relative overflow-hidden">
                        <div className="absolute inset-0 origin-top-left" style={{ transform: `translate3d(${offset.x}px, ${offset.y}px, 0) scale(${scale})` }}>
                            <svg className="absolute inset-0 w-[20000px] h-[20000px] pointer-events-none z-0">
                                {results.map(p => {
                                    const fN = renderNodeMap[p.fromId], tN = renderNodeMap[p.toId]; if (!fN || !tN) return null;
                                    const o1 = getPortOffset(p.fromPort, fN), o2 = getPortOffset(p.toPort, tN);
                                    const x1 = fN.x + o1.x, y1 = fN.y + o1.y, x2 = tN.x + o2.x, y2 = tN.y + o2.y;
                                    return (
                                        <g key={p.id}>
                                            <path ref={el => pathRefs.current[p.id] = el} d={getPathD(x1, y1, x2, y2, p.fromPort, p.toPort)} stroke={p.warning ? "#f59e0b" : "#2563eb"} strokeWidth={p.warning ? 16 : 8} fill="none" strokeLinecap="round" className={p.warning ? "warning-pulse" : ""} />
                                        </g>
                                    );
                                })}
                                {placementGroup && placementGroup.pipes.map(p => {
                                    const fN = placementGroup.nodes.find(n => n.id === p.fromId);
                                    const tN = placementGroup.nodes.find(n => n.id === p.toId);
                                    if (!fN || !tN) return null;
                                    const o1 = getPortOffset(p.fromPort, fN), o2 = getPortOffset(p.toPort, tN);
                                    const x1 = mouseWorldPos.x + fN.relativeX + o1.x, y1 = mouseWorldPos.y + fN.relativeY + o1.y;
                                    const x2 = mouseWorldPos.x + tN.relativeX + o2.x, y2 = mouseWorldPos.y + tN.relativeY + o2.y;
                                    return (
                                        <path key={`ghost-pipe-${p.id}`} d={getPathD(x1, y1, x2, y2, p.fromPort, p.toPort)} stroke="#10b981" strokeWidth={6} fill="none" strokeDasharray="10,5" className="ghost-group" />
                                    );
                                })}
                                {snapPort && <circle cx={snapPort.x} cy={snapPort.y} r={40} fill="none" stroke="#f97316" strokeWidth={8} strokeDasharray="12" className="animate-pulse active-snap" />}
                                {activeConn && <path ref={ghostPathRef} d="" stroke="#f97316" strokeWidth={8} fill="none" strokeDasharray="12,10" />}
                            </svg>

                            {results.map(p => {
                                const fN = renderNodeMap[p.fromId], tN = renderNodeMap[p.toId]; if (!fN || !tN) return null;
                                const o1 = getPortOffset(p.fromPort, fN), o2 = getPortOffset(p.toPort, tN);
                                const x1 = fN.x + o1.x, y1 = fN.y + o1.y, x2 = tN.x + o2.x, y2 = tN.y + o2.y;
                                return (
                                    <div key={`lbl-${p.id}`} ref={el => labelRefs.current[p.id] = el} className="pipe-label-html" style={{ left: (x1+x2)/2, top: (y1+y2)/2 }}>
                                        <div className="group relative flex flex-col items-center justify-center p-6 bg-slate-900 rounded-[3rem] border-4 border-white shadow-2xl transition-all hover:scale-110">
                                            <div className="text-6xl font-black text-white leading-none mb-1 tracking-tighter italic">DN{p.dn}</div>
                                            <div className="text-2xl font-black text-blue-400 mb-2 leading-none">{p.lpm.toFixed(0)} <small className="text-xs font-bold font-black">LPM</small></div>
                                            {p.warning && <div className="text-[12px] font-black uppercase text-red-500 mt-2 flex items-center gap-2 animate-pulse leading-none font-black"><Icons.AlertTriangle /> 流速過載</div>}
                                            <button onClick={() => { saveHistory(); setPipes(prev => prev.filter(pip => pip.id !== p.id))}} className="absolute -top-6 -right-6 bg-red-600 border-4 border-white rounded-full shadow-2xl text-white p-3 opacity-0 group-hover:opacity-100 hover:bg-red-700 transition-all active:scale-75 z-[200]">
                                                <Icons.X />
                                            </button>
                                        </div>
                                    </div>
                                );
                            })}

                            {placementGroup && placementGroup.nodes.map(nodeItem => {
                                const libItem = library.find(l => l.id === nodeItem.templateId);
                                const { w, h } = getNodeDimensions(nodeItem);
                                return (
                                    <div key={`ghost-${nodeItem.id}`} 
                                        style={{ left: mouseWorldPos.x + nodeItem.relativeX, top: mouseWorldPos.y + nodeItem.relativeY, width: w, height: h, outline: '4px dashed #10b981' }}
                                        className="absolute bg-white/40 rounded-[3.5rem] border-[6px] border-emerald-500/50 z-[8000] ghost-group flex items-center justify-center font-black text-2xl text-emerald-700">
                                        放置預覽: {nodeItem.label || libItem?.label}
                                    </div>
                                );
                            })}

                            {nodes.map(nodeItem => {
                                const isS = nodeItem.templateId === 'SOURCE'; const isP = nodeItem.type === 'PIVOT'; const libItem = library.find(l => l.id === nodeItem.templateId);
                                const isSel = selectedNodes.has(nodeItem.id); const flowLpm = nodeFlows[nodeItem.id] || 0; const sizing = HydraulicEngine.getSizing(flowLpm / 60);
                                const { w, h } = getNodeDimensions(nodeItem);
                                return (
                                    <div key={nodeItem.id} ref={el => nodeRefs.current[nodeItem.id] = el} 
                                        onDragStart={e => e.preventDefault()}
                                        style={{ left: nodeItem.x, top: nodeItem.y, width: w, height: h, transform: 'translate3d(0,0,0)', outline: isSel ? '12px dashed #3b82f6' : 'none', outlineOffset: '20px', zIndex: 1000 }}
                                        onClick={e => { 
                                            e.stopPropagation(); 
                                            if (placementGroup) return; 
                                            if (copyToolActive) { generatePlacementGroup([nodeItem.id]); return; }
                                            if (e.shiftKey) setSelectedNodes(prev => { const n=new Set(prev); n.has(nodeItem.id)?n.delete(nodeItem.id):n.add(nodeItem.id); return n; }); 
                                            else setSelectedNodes(new Set([nodeItem.id])); 
                                        }}
                                        className={`absolute bg-white rounded-[3.5rem] border-[6px] flex flex-col node-layer ${isS ? 'source-glow' : 'shadow-[0_40px_100px_-20px_rgba(0,0,0,0.4)]'}`}>
                                        
                                        <div className={`h-16 shrink-0 ${isS?'h-20':''} ${nodeItem.color || (isS ? 'bg-yellow-400 text-slate-900' : (isP ? 'bg-slate-800 text-white' : (nodeItem.isMerged ? 'bg-indigo-700 text-white' : (libItem?.color || 'bg-slate-400 text-white'))))} flex items-center px-8 justify-between cursor-move rounded-t-[2.9rem] shadow-xl relative` }
                                            onMouseDown={e => { 
                                                e.stopPropagation(); 
                                                if (copyToolActive || placementGroup) return;
                                                document.body.classList.add('dragging-active'); isDraggingRef.current = true;
                                                const movingSet = selectedNodes.has(nodeItem.id) ? selectedNodes : new Set([nodeItem.id]);
                                                const connected = pipesSnapshot.current.filter(p => movingSet.has(p.fromId) || movingSet.has(p.toId));
                                                dragInfo.current = { isDragging: true, id: nodeItem.id, startX: e.clientX, startY: e.clientY, connectedPipeIds: connected.map(p=>p.id), dx: 0, dy: 0 }; 
                                            }}>
                                            <input className={`font-black bg-transparent outline-none w-full border-b-2 border-transparent focus:border-white/30 tracking-tighter ${isS ? 'text-3xl text-slate-900' : (isP || nodeItem.isMerged ? 'text-2xl text-white' : 'text-xl text-white')}`} value={nodeItem.label || libItem?.label || ''} onChange={e => setNodes(prev => prev.map(n => n.id === nodeItem.id ? { ...n, label: e.target.value } : n))} placeholder="輸入名稱..." />
                                            <div className="flex items-center gap-3">
                                                {isP && <button onClick={(e) => { e.stopPropagation(); setActiveColorPickerId(activeColorPickerId === nodeItem.id ? null : nodeItem.id); }} className="text-white opacity-60 hover:opacity-100 p-1.5 transform hover:scale-125 transition-all"><Icons.Palette /></button>}
                                                <button onClick={e => { e.stopPropagation(); saveHistory(); setNodes(prev => prev.filter(n => n.id !== nodeItem.id)); }} className={`${isS ? 'text-slate-900 opacity-40' : 'text-white opacity-40'} hover:opacity-100 p-1.5 transform hover:scale-125 transition-all`}><Icons.Trash2 /></button>
                                            </div>
                                            {activeColorPickerId === nodeItem.id && (
                                                <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-4 bg-white p-3 rounded-[1.5rem] shadow-2xl border-2 z-[999] w-[160px] grid grid-cols-3 gap-2 animate-in slide-in-from-bottom-2" onMouseDown={e => e.stopPropagation()}>
                                                    {COLOR_PALETTE.map(c => (<div key={c} className={`w-8 h-8 rounded-full cursor-pointer ${c} ${nodeItem.color === c ? 'ring-2 ring-slate-800 ring-offset-2' : ''}`} onClick={() => { saveHistory(); setNodes(nodes.map(n => n.id === nodeItem.id ? { ...n, color: c } : n)); setActiveColorPickerId(null); }} />))}
                                                </div>
                                            )}
                                        </div>

                                        <div className="p-6 flex-1 flex flex-col text-slate-800 overflow-hidden font-black">
                                            {nodeItem.isMerged && (
                                                <div className="mt-1 border-b-2 pb-3 mb-4 overflow-hidden">
                                                    {Object.values(nodeItem.composition).map((c,i)=>(
                                                        <div key={i} className="text-xl text-slate-500 flex justify-between mb-1 italic tracking-tight leading-none">
                                                            <span>{c.label}</span> <b className="text-blue-600 ml-4">x{c.qty}</b>
                                                        </div>
                                                    ))}
                                                    <button onClick={(e) => { e.stopPropagation(); handleUnmerge(nodeItem.id); }} className="text-lg text-blue-600 font-bold underline mt-2 pointer-events-auto">解除大區彙整</button>
                                                </div>
                                            )}

                                            <div className="mt-auto flex flex-col gap-3 text-slate-900">
                                                {(isS || isP || nodeItem.isMerged) ? (
                                                    <div className="flex flex-col gap-4 w-full">
                                                        <div className="bg-slate-50 p-4 px-6 rounded-[2rem] border-2 border-slate-100 shadow-sm flex flex-col gap-0.5">
                                                            <span className="text-[10px] opacity-50 font-black tracking-widest uppercase">{isS ? 'SYSTEM SUM' : 'BRANCH FLOW'}</span>
                                                            <div className="flex justify-between items-end">
                                                                <span className="text-5xl font-black text-blue-700 tracking-tighter leading-none">{flowLpm.toFixed(0)}</span>
                                                                <span className="text-xl font-black text-blue-300 italic uppercase">LPM</span>
                                                            </div>
                                                        </div>
                                                        <div className="bg-slate-50 p-4 px-6 rounded-[2rem] border-2 border-slate-100 shadow-sm flex justify-between items-center group">
                                                            <span className="text-[10px] opacity-50 font-black tracking-widest uppercase">MATCH DN</span>
                                                            <span className={`font-black text-5xl px-8 py-2 rounded-[2.5rem] shadow-lg border-2 border-white transition-all transform group-hover:scale-105 leading-none ${sizing.warning ? 'bg-red-500 text-white animate-pulse' : 'bg-emerald-500 text-white'}`}>
                                                                DN{sizing.dn}
                                                            </span>
                                                        </div>
                                                    </div>
                                                ) : (
                                                    <div className="flex flex-col gap-2">
                                                        <div className="flex justify-between items-center bg-slate-50 p-3 px-6 rounded-[1.5rem] border-2 border-slate-100 shadow-sm">
                                                            <span className="text-[9px] opacity-60 font-black tracking-widest uppercase">QTY</span>
                                                            <div className="flex items-center gap-4 pointer-events-auto">
                                                                <button onClick={() => { saveHistory(); setNodes(prev => prev.map(n => n.id === nodeItem.id ? { ...n, qty: Math.max(1, (n.qty || 1) - 1) } : n))}} className="w-8 h-8 flex items-center justify-center bg-white rounded-lg border-2 shadow-sm hover:bg-slate-100 font-black text-xl">-</button>
                                                                <input type="number" className="w-10 text-center text-2xl font-black bg-transparent outline-none" value={nodeItem.qty || 1} onChange={e => { saveHistory(); setNodes(prev => prev.map(n => n.id === nodeItem.id ? { ...n, qty: Math.max(1, parseInt(e.target.value) || 1) } : n))}} />
                                                                <button onClick={() => { saveHistory(); setNodes(prev => prev.map(n => n.id === nodeItem.id ? { ...n, qty: (n.qty || 1) + 1 } : n))}} className="w-8 h-8 flex items-center justify-center bg-white rounded-lg border-2 shadow-sm hover:bg-slate-100 font-black text-xl">+</button>
                                                            </div>
                                                        </div>
                                                        <div className="flex justify-between items-center bg-slate-50 p-3 px-6 rounded-[1.5rem] border-2 border-slate-100 shadow-sm">
                                                            <span className="text-[9px] opacity-60 font-black tracking-widest uppercase">FLOW</span>
                                                            <span className="text-3xl font-black text-blue-700 tracking-tighter">{flowLpm.toFixed(0)} <small className="text-sm opacity-40">LPM</small></span>
                                                        </div>
                                                        <div className="flex justify-between items-center bg-slate-50 p-3 px-6 rounded-[1.5rem] border-2 border-slate-100 shadow-sm">
                                                            <span className="text-[9px] opacity-60 font-black tracking-widest uppercase">SIZE</span>
                                                            <span className={`text-3xl font-black px-4 py-0.5 rounded-xl ${sizing.warning ? 'bg-red-100 text-red-600 animate-pulse' : 'text-emerald-600'}`}>DN{sizing.dn}</span>
                                                        </div>
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                        
                                        {['left', 'right', 'top', 'bottom'].map(port => {
                                            const off = getPortOffset(port, nodeItem);
                                            const isActivePort = snapPort?.nodeId === nodeItem.id && snapPort?.port === port;
                                            return (<div key={port} style={{ left: off.x-16, top: off.y-16 }} className={`absolute w-8 h-8 rounded-full border-[4px] border-white z-20 port-dot shadow-xl transition-all ${isActivePort ? 'snap-active' : ''}`}
                                                    onMouseDown={e => { e.preventDefault(); e.stopPropagation(); const pO = getPortOffset(port, nodeItem); setActiveConn({ fromId: nodeItem.id, fromPort: port, startX: nodeItem.x + pO.x, startY: nodeItem.y + pO.y }); }} /> );
                                        })}
                                    </div>
                                );
                            })}
                        </div>
                        <div className="absolute top-6 right-6 bg-slate-900/95 backdrop-blur text-white p-3 rounded-[1.5rem] shadow-2xl min-w-[140px] z-[250] flex flex-col gap-3 border border-white/10 text-center">
                            <div className="flex justify-between items-center text-[10px] font-black uppercase opacity-60 px-2 tracking-widest"><span>Zoom</span><span>{(scale * 100).toFixed(0)}%</span></div>
                            <button onClick={handleResetView} className="bg-blue-600 text-white py-3 rounded-xl font-black text-xs uppercase shadow-lg hover:bg-blue-500 active:scale-95 transition-all flex items-center justify-center gap-2 pointer-events-auto"><Icons.Maximize /> 全景對焦</button>
                        </div>
                    </main>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
